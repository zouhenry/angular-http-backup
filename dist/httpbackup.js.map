{"version":3,"sources":["webpack:///webpack/bootstrap 0e2d89190b7677a2cc71","webpack:///./src/httpbackup.module.js","webpack:///./src/httpbackup.interceptor.js","webpack:///./src/httpbackup.cache.js"],"names":["angular","module","factory","provider","HttpBackupInterceptor","$q","$rootScope","$httpParamSerializerJQLike","httpBackupCache","response","responseError","urlKey","getCacheKey","config","setItem","$emit","url","cachedResponse","getItem","resolve","reject","params","$inject","HttpBackupCache","allowedUrls","storage","window","localStorage","storageKeys","setCachingRules","removeItem","clear","checkAllowed","$get","rules","key","data","isAllowed","JSON","stringify","parse","ex","Object","keys","forEach","allAllowed","reduce","allowed","regex","test"],"mappings":"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","file":"httpbackup.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0e2d89190b7677a2cc71\n **/","/**\n * Created by Henry Zou on 10/7/2016.\n *\n *\n * USAGE:\n * In the config block, register the Interceptor\n * $httpProvider.interceptors.push( 'HttpBackupInterceptor' );\n *\n */\n\nimport HttpBackupInterceptor from './httpbackup.interceptor';\nimport HttpBackupCache from './httpbackup.cache';\n\nexport default\nangular.module( 'httpbackup', [] )\n  .factory( 'httpBackupInterceptor', HttpBackupInterceptor )\n  .provider( 'httpBackupCache', HttpBackupCache );\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.module.js\n **/","/**\n * Saves previously successful ajax requests in localStorage and replays them back when thereâ€™s server response fails/network error\n */\n\nexport default function HttpBackupInterceptor( $q, $rootScope, $httpParamSerializerJQLike, httpBackupCache ) {\n\n  return {\n    response     : response,\n    responseError: responseError\n  };\n\n  function response( response ) {\n    var urlKey = getCacheKey( response.config );\n    // for every successful request, cache the response\n    httpBackupCache.setItem( urlKey, response );\n    $rootScope.$emit( 'HttpBackup_cached', { url: urlKey, response: response } );\n    return response;\n  }\n\n  function responseError( response ) {\n    var urlKey = getCacheKey( response.config );\n\n    var cachedResponse = httpBackupCache.getItem( urlKey );\n    if ( cachedResponse ) { //if response fails and there's cached data\n      $rootScope.$emit( 'HttpBackup_activated', { url: urlKey, response: cachedResponse } );\n      return $q.resolve( cachedResponse );\n    } else {\n      return $q.reject( response );\n    }\n  }\n\n  function getCacheKey( config ) {\n    return config.url + $httpParamSerializerJQLike( config.params );\n  }\n}\n\nHttpBackupInterceptor.$inject = ['$q', '$rootScope', '$httpParamSerializerJQLike', 'httpBackupCache'];\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.interceptor.js\n **/","/**\n * Caching managing\n */\n\nexport default function HttpBackupCache() {\n  let allowedUrls = [];\n  let storage     = window.localStorage;\n  let storageKeys = getItem( \"HttpBackupCacheKeys\" ) || {};\n\n  return {\n    setCachingRules, setItem, getItem, removeItem, clear, checkAllowed,\n    $get: ()=> {\n      return { setCachingRules, setItem, getItem, removeItem, clear, checkAllowed };\n    }\n  };\n\n  /**\n   * By default, all urls are cached. This allows the application to specify which urls to cache via regex\n   *\n   * @param rules - Array of regular expressions\n   */\n  function setCachingRules( rules ) {\n    allowedUrls = rules;\n  }\n\n  function setItem( key, data ) {\n    var isAllowed = checkAllowed( key );\n    if ( !isAllowed ) {\n      return;\n    }\n\n    storage.setItem( key, JSON.stringify( data ) );\n    if ( key !== \"HttpBackupCacheKeys\" ) {\n      storageKeys[key] = true;\n      setItem( \"HttpBackupCacheKeys\", storageKeys );\n    }\n  }\n\n  function getItem( key ) {\n    var data = storage.getItem( key );\n    try {\n      return JSON.parse( data );\n    } catch ( ex ) {\n      return null;\n    }\n  }\n\n  function removeItem( key ) {\n    storage.removeItem( key );\n\n    delete storageKeys[key];\n    setItem( \"HttpBackupCacheKeys\", storageKeys );\n  }\n\n  function clear() {\n    Object.keys( storageKeys ).forEach( ( key )=> {\n      delete storageKeys[key];\n      removeItem( key );\n    } );\n    setItem( \"HttpBackupCacheKeys\", storageKeys );\n  }\n\n  function checkAllowed( url ) {\n    if ( url === \"HttpBackupCacheKeys\" ) {\n      return true;\n    }\n\n    var allAllowed = allowedUrls.reduce( ( allowed, regex ) => {\n      return allowed && regex.test( url );\n    }, true );\n    return allAllowed;\n  }\n}\nHttpBackupCache.$inject = [];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.cache.js\n **/"],"sourceRoot":""}