{"version":3,"sources":["webpack:///webpack/bootstrap 1647042657b96c286da4","webpack:///./src/httpbackup.module.js","webpack:///./src/httpbackup.interceptor.js","webpack:///./src/httpbackup.cache.js"],"names":["angular","module","factory","provider","HttpBackupInterceptor","$q","$rootScope","$httpParamSerializerJQLike","httpBackupCache","response","responseError","setItem","getCacheKey","config","console","log","data","getItem","$emit","url","resolve","reject","params","$inject","HttpBackupCache","allowedUrls","storage","window","localStorage","storageKeys","setCachingRules","removeItem","clear","checkAllowed","$get","rules","key","isAllowed","JSON","stringify","parse","ex","Object","keys","forEach","allAllowed","reduce","allowed","regex","test"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA,QAAO,eAAe,SAAS,cAAc;GAC3C,OAAO;;;AAOT;;AAFA,KAAI,eAAe,uBAAuB;;AAG1C;;AACA,KAAI,eAAe,uBAAuB;;AAE1C,UAAS,uBAAuB,KAAK,EAAE,OAAO,OAAO,IAAI,aAAa,MAAM,EAAE,SAAS;;;;;;;;;;;;AAYvF,SAAQ,UAZRA,QAAQC,OAAQ,cAAc,IAC3BC,QAAS,yBADZ,sBAEGC,SAAU,mBAFb,sB;;;;;;ACdA;;AAEA,QAAO,eAAe,SAAS,cAAc;GAC3C,OAAO;;AAET,SAAQ,UADgBC;;;;;AAAT,UAASA,sBAAuBC,IAAIC,YAAYC,4BAA4BC,iBAAkB;;GAE3G,OAAO;KACLC,UAAeA;KACfC,eAAeA;;;GAGjB,SAASD,SAAUA,UAAW;;KAE5BD,gBAAgBG,QAASC,YAAaH,SAASI,SAAUJ;KACzD,OAAOA;;;GAGT,SAASC,cAAeD,UAAW;KACjCK,QAAQC,IAAK;KACb,IAAIC,OAAOR,gBAAgBS,QAASL,YAAaH,SAASI;KAC1D,IAAKG,MAAO;;OACVV,WAAWY,MAAO,wBAAwB,EAAEC,KAAKV,SAASI,OAAOM,KAAKV,UAAUO;OAChF,OAAOX,GAAGe,QAASJ;YACd;OACL,OAAOX,GAAGgB,OAAQZ;;;;GAItB,SAASG,YAAaC,QAAS;KAC7B,OAAOA,OAAOM,MAAMZ,2BAA4BM,OAAOS;;;;AAI3DlB,uBAAsBmB,UAAU,CAAC,MAAM,cAAc,8BAA8B,mB;;;;;;ACjCnF;;AAEA,QAAO,eAAe,SAAS,cAAc;GAC3C,OAAO;;AAET,SAAQ,UADgBC;;;;;AAAT,UAASA,kBAAkB;GACxC,IAAIC,cAAc;GAClB,IAAIC,UAAcC,OAAOC;GACzB,IAAIC,cAAcZ,QAAS,0BAA2B;;GAEtD,OAAO;KACLa,kCAAiBnB,kBAASM,kBAASc,wBAAYC,cAAOC;KACtDC,MAAM,gBAAK;OACT,OAAO,EAAEJ,kCAAiBnB,kBAASM,kBAASc,wBAAYC,cAAOC;;;;;;;;;GASnE,SAASH,gBAAiBK,OAAQ;KAChCV,cAAcU;;;GAGhB,SAASxB,QAASyB,KAAKpB,MAAO;KAC5B,IAAIqB,YAAYJ,aAAcG;KAC9B,IAAK,CAACC,WAAY;OAChB;;;KAGFX,QAAQf,QAASyB,KAAKE,KAAKC,UAAWvB;KACtC,IAAKoB,QAAQ,uBAAwB;OACnCP,YAAYO,OAAO;OACnBzB,QAAS,uBAAuBkB;;;;GAIpC,SAASZ,QAASmB,KAAM;KACtB,IAAIpB,OAAOU,QAAQT,QAASmB;KAC5B,IAAI;OACF,OAAOE,KAAKE,MAAOxB;OACnB,OAAQyB,IAAK;OACb,OAAO;;;;GAIX,SAASV,WAAYK,KAAM;KACzBV,QAAQK,WAAYK;;KAEpB,OAAOP,YAAYO;KACnBzB,QAAS,uBAAuBkB;;;GAGlC,SAASG,QAAQ;KACfU,OAAOC,KAAMd,aAAce,QAAS,UAAER,KAAQ;OAC5C,OAAOP,YAAYO;OACnBL,WAAYK;;KAEdzB,QAAS,uBAAuBkB;;;GAGlC,SAASI,aAAcd,KAAM;KAC3B,IAAKA,QAAQ,uBAAwB;OACnC,OAAO;;;KAGT,IAAI0B,aAAapB,YAAYqB,OAAQ,UAAEC,SAASC,OAAW;OACzD,OAAOD,WAAWC,MAAMC,KAAM9B;QAC7B;KACH,OAAO0B;;;AAGXrB,iBAAgBD,UAAU,G","file":"httpbackup.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1647042657b96c286da4\n **/","/**\n * Created by Henry Zou on 10/7/2016.\n *\n *\n * USAGE:\n * In the config block, register the Interceptor\n * $httpProvider.interceptors.push( 'HttpBackupInterceptor' );\n *\n */\n\nimport HttpBackupInterceptor from './httpbackup.interceptor';\nimport HttpBackupCache from './httpbackup.cache';\n\nexport default\nangular.module( 'httpbackup', [] )\n  .factory( 'httpBackupInterceptor', HttpBackupInterceptor )\n  .provider( 'httpBackupCache', HttpBackupCache );\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.module.js\n **/","/**\n * Saves previously successful ajax requests in localStorage and replays them back when thereâ€™s server response fails/network error\n */\n\nexport default function HttpBackupInterceptor( $q, $rootScope, $httpParamSerializerJQLike, httpBackupCache ) {\n\n  return {\n    response     : response,\n    responseError: responseError\n  };\n\n  function response( response ) {\n    // for every successful request, cache the response\n    httpBackupCache.setItem( getCacheKey( response.config ), response );\n    return response;\n  }\n\n  function responseError( response ) {\n    console.log( 'before getKey' );\n    var data = httpBackupCache.getItem( getCacheKey( response.config ) );\n    if ( data ) { //if response fails and there's cached data\n      $rootScope.$emit( 'HttpBackup_activated', { url: response.config.url, response: data } );\n      return $q.resolve( data );\n    } else {\n      return $q.reject( response );\n    }\n  }\n\n  function getCacheKey( config ) {\n    return config.url + $httpParamSerializerJQLike( config.params );\n  }\n}\n\nHttpBackupInterceptor.$inject = ['$q', '$rootScope', '$httpParamSerializerJQLike', 'httpBackupCache'];\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.interceptor.js\n **/","/**\n * Caching managing\n */\n\nexport default function HttpBackupCache() {\n  let allowedUrls = [];\n  let storage     = window.localStorage;\n  let storageKeys = getItem( \"HttpBackupCacheKeys\" ) || {};\n\n  return {\n    setCachingRules, setItem, getItem, removeItem, clear, checkAllowed,\n    $get: ()=> {\n      return { setCachingRules, setItem, getItem, removeItem, clear, checkAllowed };\n    }\n  };\n\n  /**\n   * By default, all urls are cached. This allows the application to specify which urls to cache via regex\n   *\n   * @param rules - Array of regular expressions\n   */\n  function setCachingRules( rules ) {\n    allowedUrls = rules;\n  }\n\n  function setItem( key, data ) {\n    var isAllowed = checkAllowed( key );\n    if ( !isAllowed ) {\n      return;\n    }\n\n    storage.setItem( key, JSON.stringify( data ) );\n    if ( key !== \"HttpBackupCacheKeys\" ) {\n      storageKeys[key] = true;\n      setItem( \"HttpBackupCacheKeys\", storageKeys );\n    }\n  }\n\n  function getItem( key ) {\n    var data = storage.getItem( key );\n    try {\n      return JSON.parse( data );\n    } catch ( ex ) {\n      return null;\n    }\n  }\n\n  function removeItem( key ) {\n    storage.removeItem( key );\n\n    delete storageKeys[key];\n    setItem( \"HttpBackupCacheKeys\", storageKeys );\n  }\n\n  function clear() {\n    Object.keys( storageKeys ).forEach( ( key )=> {\n      delete storageKeys[key];\n      removeItem( key );\n    } );\n    setItem( \"HttpBackupCacheKeys\", storageKeys );\n  }\n\n  function checkAllowed( url ) {\n    if ( url === \"HttpBackupCacheKeys\" ) {\n      return true;\n    }\n\n    var allAllowed = allowedUrls.reduce( ( allowed, regex ) => {\n      return allowed && regex.test( url );\n    }, true );\n    return allAllowed;\n  }\n}\nHttpBackupCache.$inject = [];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.cache.js\n **/"],"sourceRoot":""}