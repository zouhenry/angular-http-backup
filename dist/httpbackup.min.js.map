{"version":3,"sources":["webpack:///httpbackup.min.js","webpack:///webpack/bootstrap 320269c6bee1a43c735a?27a5","webpack:///./src/httpbackup.module.js?25e6","webpack:///./src/httpbackup.interceptor.js?e37f","webpack:///./src/httpbackup.cache.js?63a1"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_httpbackup","_httpbackup2","_httpbackup3","_httpbackup4","angular","factory","provider","HttpBackupInterceptor","$q","$rootScope","$httpParamSerializerJQLike","httpBackupCache","response","urlKey","getCacheKey","config","setItem","$emit","url","responseError","cachedResponse","getItem","resolve","reject","method","params","$inject","HttpBackupCache","setCachingRules","rules","allowedUrls","key","data","isAllowed","checkAllowed","storage","JSON","stringify","storageKeys","parse","ex","removeItem","clear","keys","forEach","allAllowed","reduce","allowed","regex","test","window","localStorage","$get"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GE5ChC,YAcA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAZvFG,OAAOC,eAAeb,EAAS,cAC7Bc,OAAO,GAOT,IAAAC,GAAAlB,EAAA,GAFImB,EAAeR,EAAuBO,GAG1CE,EAAApB,EAAA,GACIqB,EAAeV,EAAuBS,EAc1CjB,cAZAmB,QAAQlB,OAAQ,iBACbmB,QAAS,wBADZJ,cAEGK,SAAU,kBAFbH,eF8DM,SAASjB,EAAQD,GG5EvB,YAIe,SAASsB,GAAuBC,EAAIC,EAAYC,EAA4BC,GAOzF,QAASC,GAAUA,GACjB,GAAIC,GAASC,EAAaF,EAASG,OAInC,OAFAJ,GAAgBK,QAASH,EAAQD,GACjCH,EAAWQ,MAAO,qBAAuBC,IAAKL,EAAQD,SAAUA,IACzDA,EAGT,QAASO,GAAeP,GACtB,GAAIC,GAASC,EAAaF,EAASG,QAE/BK,EAAiBT,EAAgBU,QAASR,EAC9C,OAAKO,IACHX,EAAWQ,MAAO,wBAA0BC,IAAKL,EAAQD,SAAUQ,IAC5DZ,EAAGc,QAASF,IAEZZ,EAAGe,OAAQX,GAItB,QAASE,GAAaC,GACpB,MAAOA,GAAOS,OAAS,IAAMT,EAAOG,IAAMR,EAA4BK,EAAOU,QA1B/E,OACEb,SAAeA,EACfO,cAAeA,GANnBtB,OAAOC,eAAeb,EAAS,cAC7Bc,OAAO,IAETd,aADwBsB,EAgCxBA,EAAsBmB,SAAW,KAAM,aAAc,6BAA8B,oBHyF7E,SAASxC,EAAQD,GI7HvB,YAIe,SAAS0C,KAiBtB,QAASC,GAAiBC,GACxBC,EAAcD,EAGhB,QAASb,GAASe,EAAKC,GACrB,GAAIC,GAAYC,EAAcH,EACxBE,KAINE,EAAQnB,QAASe,EAAKK,KAAKC,UAAWL,IACzB,wBAARD,IACHO,EAAYP,IAAO,EACnBf,EAAS,sBAAuBsB,KAIpC,QAASjB,GAASU,GAChB,GAAIC,GAAOG,EAAQd,QAASU,EAC5B,KACE,MAAOK,MAAKG,MAAOP,GACnB,MAAQQ,GACR,MAAO,OAIX,QAASC,GAAYV,GACnBI,EAAQM,WAAYV,SAEbO,GAAYP,GACnBf,EAAS,sBAAuBsB,GAGlC,QAASI,KACP7C,OAAO8C,KAAML,GAAcM,QAAS,SAAEb,SAC7BO,GAAYP,GACnBU,EAAYV,KAEdf,EAAS,sBAAuBsB,GAGlC,QAASJ,GAAchB,GACrB,GAAa,wBAARA,EACH,OAAO,CAGT,IAAI2B,GAAaf,EAAYgB,OAAQ,SAAEC,EAASC,GAC9C,MAAOD,IAAWC,EAAMC,KAAM/B,KAC7B,EACH,OAAO2B,GAjET,GAAIf,MACAK,EAAce,OAAOC,aACrBb,EAAcjB,EAAS,0BAE3B,QACEO,kBAAiBZ,UAASK,UAASoB,aAAYC,QAAOR,eACtDkB,KAAM,WACJ,OAASxB,kBAAiBZ,UAASK,UAASoB,aAAYC,QAAOR,kBAVrErC,OAAOC,eAAeb,EAAS,cAC7Bc,OAAO,IAETd,aADwB0C,EAqExBA,EAAgBD","file":"httpbackup.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _httpbackup = __webpack_require__(1);\n\t\n\tvar _httpbackup2 = _interopRequireDefault(_httpbackup);\n\t\n\tvar _httpbackup3 = __webpack_require__(2);\n\t\n\tvar _httpbackup4 = _interopRequireDefault(_httpbackup3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Created by Henry Zou on 10/7/2016.\n\t *\n\t *\n\t * USAGE:\n\t * In the config block, register the Interceptor\n\t * $httpProvider.interceptors.push( 'HttpBackupInterceptor' );\n\t *\n\t */\n\t\n\texports.default = angular.module('httpbackup', []).factory('httpBackupInterceptor', _httpbackup2.default).provider('httpBackupCache', _httpbackup4.default);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = HttpBackupInterceptor;\n\t/**\n\t * Saves previously successful ajax requests in localStorage and replays them back when there’s server response fails/network error\n\t */\n\t\n\tfunction HttpBackupInterceptor($q, $rootScope, $httpParamSerializerJQLike, httpBackupCache) {\n\t\n\t  return {\n\t    response: response,\n\t    responseError: responseError\n\t  };\n\t\n\t  function response(response) {\n\t    var urlKey = getCacheKey(response.config);\n\t    // for every successful request, cache the response\n\t    httpBackupCache.setItem(urlKey, response);\n\t    $rootScope.$emit('HttpBackup_cached', { url: urlKey, response: response });\n\t    return response;\n\t  }\n\t\n\t  function responseError(response) {\n\t    var urlKey = getCacheKey(response.config);\n\t\n\t    var cachedResponse = httpBackupCache.getItem(urlKey);\n\t    if (cachedResponse) {\n\t      //if response fails and there's cached data\n\t      $rootScope.$emit('HttpBackup_activated', { url: urlKey, response: cachedResponse });\n\t      return $q.resolve(cachedResponse);\n\t    } else {\n\t      return $q.reject(response);\n\t    }\n\t  }\n\t\n\t  function getCacheKey(config) {\n\t    return config.method + \":\" + config.url + $httpParamSerializerJQLike(config.params);\n\t  }\n\t}\n\t\n\tHttpBackupInterceptor.$inject = ['$q', '$rootScope', '$httpParamSerializerJQLike', 'httpBackupCache'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = HttpBackupCache;\n\t/**\n\t * Caching managing\n\t */\n\t\n\tfunction HttpBackupCache() {\n\t  var allowedUrls = [];\n\t  var storage = window.localStorage;\n\t  var storageKeys = getItem(\"HttpBackupCacheKeys\") || {};\n\t\n\t  return {\n\t    setCachingRules: setCachingRules, setItem: setItem, getItem: getItem, removeItem: removeItem, clear: clear, checkAllowed: checkAllowed,\n\t    $get: function $get() {\n\t      return { setCachingRules: setCachingRules, setItem: setItem, getItem: getItem, removeItem: removeItem, clear: clear, checkAllowed: checkAllowed };\n\t    }\n\t  };\n\t\n\t  /**\n\t   * By default, all urls are cached. This allows the application to specify which urls to cache via regex\n\t   *\n\t   * @param rules - Array of regular expressions\n\t   */\n\t  function setCachingRules(rules) {\n\t    allowedUrls = rules;\n\t  }\n\t\n\t  function setItem(key, data) {\n\t    var isAllowed = checkAllowed(key);\n\t    if (!isAllowed) {\n\t      return;\n\t    }\n\t\n\t    storage.setItem(key, JSON.stringify(data));\n\t    if (key !== \"HttpBackupCacheKeys\") {\n\t      storageKeys[key] = true;\n\t      setItem(\"HttpBackupCacheKeys\", storageKeys);\n\t    }\n\t  }\n\t\n\t  function getItem(key) {\n\t    var data = storage.getItem(key);\n\t    try {\n\t      return JSON.parse(data);\n\t    } catch (ex) {\n\t      return null;\n\t    }\n\t  }\n\t\n\t  function removeItem(key) {\n\t    storage.removeItem(key);\n\t\n\t    delete storageKeys[key];\n\t    setItem(\"HttpBackupCacheKeys\", storageKeys);\n\t  }\n\t\n\t  function clear() {\n\t    Object.keys(storageKeys).forEach(function (key) {\n\t      delete storageKeys[key];\n\t      removeItem(key);\n\t    });\n\t    setItem(\"HttpBackupCacheKeys\", storageKeys);\n\t  }\n\t\n\t  function checkAllowed(url) {\n\t    if (url === \"HttpBackupCacheKeys\") {\n\t      return true;\n\t    }\n\t\n\t    var allAllowed = allowedUrls.reduce(function (allowed, regex) {\n\t      return allowed && regex.test(url);\n\t    }, true);\n\t    return allAllowed;\n\t  }\n\t}\n\tHttpBackupCache.$inject = [];\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** httpbackup.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 320269c6bee1a43c735a\n **/","/**\n * Created by Henry Zou on 10/7/2016.\n *\n *\n * USAGE:\n * In the config block, register the Interceptor\n * $httpProvider.interceptors.push( 'HttpBackupInterceptor' );\n *\n */\n\nimport HttpBackupInterceptor from './httpbackup.interceptor';\nimport HttpBackupCache from './httpbackup.cache';\n\nexport default\nangular.module( 'httpbackup', [] )\n  .factory( 'httpBackupInterceptor', HttpBackupInterceptor )\n  .provider( 'httpBackupCache', HttpBackupCache );\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.module.js\n **/","/**\n * Saves previously successful ajax requests in localStorage and replays them back when there’s server response fails/network error\n */\n\nexport default function HttpBackupInterceptor( $q, $rootScope, $httpParamSerializerJQLike, httpBackupCache ) {\n\n  return {\n    response     : response,\n    responseError: responseError\n  };\n\n  function response( response ) {\n    var urlKey = getCacheKey( response.config );\n    // for every successful request, cache the response\n    httpBackupCache.setItem( urlKey, response );\n    $rootScope.$emit( 'HttpBackup_cached', { url: urlKey, response: response } );\n    return response;\n  }\n\n  function responseError( response ) {\n    var urlKey = getCacheKey( response.config );\n\n    var cachedResponse = httpBackupCache.getItem( urlKey );\n    if ( cachedResponse ) { //if response fails and there's cached data\n      $rootScope.$emit( 'HttpBackup_activated', { url: urlKey, response: cachedResponse } );\n      return $q.resolve( cachedResponse );\n    } else {\n      return $q.reject( response );\n    }\n  }\n\n  function getCacheKey( config ) {\n    return config.method + \":\" + config.url + $httpParamSerializerJQLike( config.params );\n  }\n}\n\nHttpBackupInterceptor.$inject = ['$q', '$rootScope', '$httpParamSerializerJQLike', 'httpBackupCache'];\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.interceptor.js\n **/","/**\n * Caching managing\n */\n\nexport default function HttpBackupCache() {\n  let allowedUrls = [];\n  let storage     = window.localStorage;\n  let storageKeys = getItem( \"HttpBackupCacheKeys\" ) || {};\n\n  return {\n    setCachingRules, setItem, getItem, removeItem, clear, checkAllowed,\n    $get: ()=> {\n      return { setCachingRules, setItem, getItem, removeItem, clear, checkAllowed };\n    }\n  };\n\n  /**\n   * By default, all urls are cached. This allows the application to specify which urls to cache via regex\n   *\n   * @param rules - Array of regular expressions\n   */\n  function setCachingRules( rules ) {\n    allowedUrls = rules;\n  }\n\n  function setItem( key, data ) {\n    var isAllowed = checkAllowed( key );\n    if ( !isAllowed ) {\n      return;\n    }\n\n    storage.setItem( key, JSON.stringify( data ) );\n    if ( key !== \"HttpBackupCacheKeys\" ) {\n      storageKeys[key] = true;\n      setItem( \"HttpBackupCacheKeys\", storageKeys );\n    }\n  }\n\n  function getItem( key ) {\n    var data = storage.getItem( key );\n    try {\n      return JSON.parse( data );\n    } catch ( ex ) {\n      return null;\n    }\n  }\n\n  function removeItem( key ) {\n    storage.removeItem( key );\n\n    delete storageKeys[key];\n    setItem( \"HttpBackupCacheKeys\", storageKeys );\n  }\n\n  function clear() {\n    Object.keys( storageKeys ).forEach( ( key )=> {\n      delete storageKeys[key];\n      removeItem( key );\n    } );\n    setItem( \"HttpBackupCacheKeys\", storageKeys );\n  }\n\n  function checkAllowed( url ) {\n    if ( url === \"HttpBackupCacheKeys\" ) {\n      return true;\n    }\n\n    var allAllowed = allowedUrls.reduce( ( allowed, regex ) => {\n      return allowed && regex.test( url );\n    }, true );\n    return allAllowed;\n  }\n}\nHttpBackupCache.$inject = [];\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/httpbackup.cache.js\n **/"],"sourceRoot":""}